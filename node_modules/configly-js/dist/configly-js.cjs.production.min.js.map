{"version":3,"file":"configly-js.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["const axios = require('axios');\nconst qs = require('qs');\nconst removeSlash = require('remove-trailing-slash');\n\nconst VERSION = require('../package.json').version;\n\nconst GET_API_PATH = '/api/v1/value';\n\ninterface ConfiglyOptions {\n  host?: string;\n  enableCache?: boolean;\n  timeout?: number;\n}\n\n/**\n * Config.ly: the dead simple place to store and retrieve your static/config data.\n *\n * Remember: *do NOT* assign the result of a get() to a long-lived variable; in order for\n * the value to fetch from the server, you must call get().\n *\n * Each get(key) returns a Promise; the first argument to the Promise fulfillment method is the\n * Configly value for the supplied key. Please see the example:\n *\n * const Configly = require('Configly');\n * const configly = Configly.init('API_KEY');\n *\n * configly.get('keyOne').then((valueForKeyOne) => console.log(valueForKeyOne));\n *\n * // or\n *\n * const run = async () => {\n *   return await configly.get('keyOne');\n * }\n *\n * Note that get(key) may make a server request or fetch a cached value. You should\n * assume it'll make a (fast) HTTP request. If you need something guaranteed to be faster, we\n * recommend storing the value to a local variable; BUT, be aware that this means you won't\n * receive updates to that variable, so be sure to call get() periodically.\n */\nexport class Configly {\n  private static instance?: Configly;\n  private cache: Record<string, any>;\n  private cacheTtl: Record<string, number>;\n  private apiKey: string;\n  private options: ConfiglyOptions;\n\n  /**\n   * This method should NOT be called externally; please use Configly.init().\n   */\n  private constructor () {\n    this.cache = {};\n    this.cacheTtl = {};\n    this.apiKey = '';\n\n    this.options = {\n      host: 'https://api.config.ly',\n      timeout: 3000,\n      enableCache: true,\n    }\n  }\n\n  /*\n   * Initialize the `Configly` singleton with your account's `API Key` and an\n   * optional dictionary of `options`.\n   *\n   * @param {String} apiKey - your readonly Config.ly API key. You can find it at\n   *   http://config.ly/config.\n   * @param {Object} [options] (optional)\n   *     @property {Number} host (default: https://config.ly/) - Overrides the host for requests\n   *     @property {Number} enableCache (default: true) - disables the cache, resulting in an HTTP\n   *       fetch on every `get` call\n   *     @property {Number} timeout (default: 3000) - ms timeout for requests to Configly for data.\n   * @return Configly instance\n   * @throws Error if an API Key is not supplied or if init is called multiple times.\n   */\n  static init(apiKey: string, options?: ConfiglyOptions) {\n    if (!apiKey || !apiKey.length || apiKey.length == 0) {\n      throw new Error('You must supply your API Key. You can find it by logging in to Config.ly');\n    }\n\n    if (!!Configly.instance) {\n      throw new Error('configly.init() is called multiple times. It can only be called once.');\n    }\n\n    let inst = new Configly();\n    options = options || {};\n    inst.options.host = removeSlash(options.host || inst.options.host);\n    inst.options.enableCache = \n        options.enableCache === undefined ? inst.options.enableCache : options.enableCache;\n    inst.apiKey = apiKey;\n    inst.options.timeout = options.timeout || inst.options.timeout;\n\n    Configly.instance = inst;\n    return Configly.instance;\n  }\n\n  /*\n   * @return existing Configy instance. Configly.init() must be called before any invocation of\n   * getInstance()\n   */\n  static getInstance(): Configly {\n    if (!Configly.isInitialized()) {\n      throw new Error('Configly.getInstance() is called before Configly.init(); you must call init.');\n    }\n    return Configly.instance!;\n  }\n\n  /*\n   * @return true if init() has been called\n   */\n  static isInitialized(): boolean {\n    return !!Configly.instance;\n  }\n  static getUnixTimestampSecs(): number {\n    return Math.round(Date.now() / 1000);\n  }\n\n  _isCached(key: string): boolean {\n    let value = this.cache[key];\n    if (!value) {\n      return false;\n    }\n    if (this.cacheTtl[key] < Configly.getUnixTimestampSecs()) {\n      return false\n    }\n    return true;\n  }\n\n  _cacheGet(key: string): any {\n    return this.cache[key];\n  }\n\n  /**\n   * Fetch the value for the supplied key. This is an async call; it may be lightning fast as the\n   * value may be cached.\n   *\n   * Configly.init() must be called before any invocation of get\n   *\n   * @param {String} key - the key to fetch.\n   * @param {Object?} [options] overrides the global parameters set in the constructor for this\n   *  `get` request only (optional)\n   *     @property {Number} enableCache (default: true) - disables the cache, resulting in an HTTP\n   *       fetch on every `get` call.\n   *     @property {Number} timeout (default: 3000) - timeout for request to Configly for data in ms.\n   * @return { Promse<String | Number | Boolean | Array | Object | Error> } returns, on success,\n   *   a promise of fulfilled with the stored value(s) as typed in Config.ly. On error, returns\n   *   a failed promise with error:\n   *     - TypeError if key is not a string or omitted\n   *     - Error if key an empty string\n   */\n  get(key: string, options?: ConfiglyOptions): Promise<any> {\n    if (typeof key !== 'string') {\n      return Promise.reject(new TypeError('key must be a string'));\n    }\n    if (!key || key.length == 0) {\n      return Promise.reject(new Error('key must be a non-empty string'));\n    }\n\n    options = options || {};\n\n    const headers: Record<string, string> = {\n      'Accept': 'application/json',\n    };\n\n    // XXX: I think setting custom headers of X- is deprecated but I couldn't find another good\n    // header to use.\n    headers['X-Lib-Version'] = ['configly-node', VERSION].join('/');\n\n    let cacheIsEnabled = true;\n    if (options.enableCache !== undefined) {\n      cacheIsEnabled = options.enableCache;\n    } else if (!this.options.enableCache) {\n      cacheIsEnabled = false;\n    }\n\n    // Check the cache\n    if (cacheIsEnabled && this._isCached(key)) {\n      return Promise.resolve(this._cacheGet(key));\n    }\n\n    let url = `${this.options.host}${GET_API_PATH}`;\n    return axios.get(\n      url,\n      {\n        auth: {\n          username: this.apiKey,\n        },\n        headers,\n        params: { keys: [ key ] },\n        paramsSerializer: (params: any) => {\n          return qs.stringify(params, {arrayFormat: 'brackets'})\n        },\n        timeout: options.timeout || this.options.timeout || 3000,\n      }\n    ).then((response: any) => {\n      let { value, ttl } = response.data.data[ key ] || {};\n\n      // There should always be a TTL. But just in case.\n      ttl = ttl || 60;\n      if (cacheIsEnabled && value !== undefined) {\n        this.cacheTtl[key] = Configly.getUnixTimestampSecs() + ttl;\n        this.cache[key] = value;\n      }\n\n      return value;\n    }).catch(Configly.handleGetError);\n  }\n  static makeError(status: string, message: string, originalError: any) {\n    return { status, message, originalError }\n  }\n\n  static handleGetError(error: any) {\n    let status = ERRORS.OTHER;\n    let message = [\n      'Something went wrong. Have you upgraded to the latest client?',\n      \"Take a look at 'originalError' inside the error object for more details.\"\n    ].join('');\n\n    if (error.response) {\n      const statusCode: number = error.response.status;\n      status = statusCode === 401 ? ERRORS.INVALID_API_KEY : ERRORS.OTHER;\n      message = (error.response.data || '').substring(0, 1000);\n    } else if (error.code === 'ECONNREFUSED') {\n      status = ERRORS.CONNECTION_ERROR;\n      message = [\n        'Configly didn\\'t receive an HTTP response.',\n        'This could be because of a network disruption with the server or a bad supplied hostname.',\n        'If you\\'ve supplied a host parameter, please ensure it is correct.',\n        'Otherwise, try again.'\n      ].join(' ');\n    }\n    return Promise.reject(Configly.makeError(status, message, error));\n  };\n\n  /**\n   * Destroys singleton; really meant for testing snd likely should not be used\n   * externally.\n   */\n  destroy() {\n    Configly.instance = undefined;\n  }\n}\n\nexport const ERRORS = {\n  OTHER: 'OTHER',\n  CONNECTION_ERROR: 'CONNECTION_ERROR',\n  INVALID_API_KEY: 'INVALID_API_KEY',\n};\nObject.freeze(ERRORS);\n\nexport default Configly;"],"names":["axios","require","qs","removeSlash","VERSION","version","Configly","cache","cacheTtl","apiKey","options","host","timeout","enableCache","init","length","Error","instance","inst","undefined","getInstance","isInitialized","getUnixTimestampSecs","Math","round","Date","now","_isCached","key","this","_cacheGet","get","Promise","reject","TypeError","headers","join","cacheIsEnabled","resolve","auth","username","params","keys","paramsSerializer","stringify","arrayFormat","then","response","data","value","ttl","_this","handleGetError","makeError","status","message","originalError","error","ERRORS","OTHER","INVALID_API_KEY","substring","code","CONNECTION_ERROR","destroy","Object","freeze"],"mappings":"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"}